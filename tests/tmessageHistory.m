classdef tmessageHistory < matlab.unittest.TestCase
% Tests for messageHistory

%   Copyright 2023-2024 The MathWorks, Inc.

    properties(TestParameter)
        InvalidInputsUserPrompt = iGetInvalidInputsUserPrompt();
        InvalidInputsUserImagesPrompt = iGetInvalidInputsUserImagesPrompt();
        InvalidInputsFunctionPrompt = iGetInvalidFunctionPrompt();
        InvalidInputsSystemPrompt = iGetInvalidInputsSystemPrompt();
        InvalidInputsResponseMessage = iGetInvalidInputsResponseMessage();
        InvalidRemoveMessage = iGetInvalidRemoveMessage();
        InvalidFuncCallsCases = iGetInvalidFuncCallsCases()
        ValidTextInput = {"This is okay"; 'this is ok'};
    end

    methods(Test)
        function constructorStartsWithEmptyMessages(testCase)
            msgs = messageHistory;
            testCase.verifyTrue(isempty(msgs.Messages));
        end

        function differentInputTextAccepted(testCase, ValidTextInput)
            msgs = messageHistory;
            testCase.verifyWarningFree(@()addSystemMessage(msgs, ValidTextInput, ValidTextInput));
            testCase.verifyWarningFree(@()addSystemMessage(msgs, ValidTextInput, ValidTextInput));
            testCase.verifyWarningFree(@()addUserMessage(msgs, ValidTextInput));
            testCase.verifyWarningFree(@()addToolMessage(msgs, ValidTextInput, ValidTextInput, ValidTextInput));
        end

        function systemMessageIsAdded(testCase)
            prompt = "Here is a system prompt";
            name = "example";
            msgs = messageHistory;
            systemPrompt = struct("role", "system", "name", name, "content", prompt);
            msgs = addSystemMessage(msgs, name, prompt);
            testCase.verifyEqual(msgs.Messages{1}, systemPrompt);
        end

        function userMessageIsAdded(testCase)
            prompt = "Here is a user prompt";
            msgs = messageHistory;
            userPrompt = struct("role", "user", "content", prompt);
            msgs = addUserMessage(msgs, prompt);
            testCase.verifyEqual(msgs.Messages{1}, userPrompt);
        end

        function userImageMessageIsAddedWithLocalImg(testCase)
            prompt = "Here is a user prompt";
            msgs = messageHistory;
            img = "peppers.png";
            testCase.verifyWarningFree(@()addUserMessageWithImages(msgs, prompt, img));
        end

        function userImageMessageIsAddedWithRemoteImg(testCase)
            prompt = "Here is a user prompt";
            msgs = messageHistory;
            img = "https://www.mathworks.com/help/examples/matlab/win64/DisplayGrayscaleRGBIndexedOrBinaryImageExample_04.png";
            testCase.verifyWarningFree(@()addUserMessageWithImages(msgs, prompt, img));
        end

        function toolMessageIsAdded(testCase)
            prompt = "20";
            name = "sin";
            id = "123";
            msgs = messageHistory;
            systemPrompt = struct("tool_call_id", id, "role", "tool", "name", name, "content", prompt);
            msgs = addToolMessage(msgs, id, name, prompt);
            testCase.verifyEqual(msgs.Messages{1}, systemPrompt);
        end

        function assistantMessageIsAdded(testCase)
            prompt = "Here is an assistant prompt";
            msgs = messageHistory;
            assistantPrompt = struct("role", "assistant", "content", prompt);
            msgs = addResponseMessage(msgs, assistantPrompt);
            testCase.verifyEqual(msgs.Messages{1}, assistantPrompt);
        end

        function assistantToolCallMessageIsAdded(testCase)
            msgs = messageHistory;
            functionName = "functionName";
            args = "{""arg1"": 1, ""arg2"": 2, ""arg3"": ""3""}";
            funCall = struct("name", functionName, "arguments", args);
            toolCall = struct("id", "123", "type", "function", "function", funCall);
            toolCallPrompt = struct("role", "assistant", "content", "", "tool_calls", []);
            % tool_calls is an array of struct in API response
            toolCallPrompt.tool_calls = toolCall;
            msgs = addResponseMessage(msgs, toolCallPrompt);
            % to include in msgs, tool_calls must be a cell
            testCase.verifyEqual(fieldnames(msgs.Messages{1}), fieldnames(toolCallPrompt));
            testCase.verifyEqual(msgs.Messages{1}.tool_calls{1}, toolCallPrompt.tool_calls);
        end

        function errorsAssistantWithWithoutToolCallId(testCase)
            msgs = messageHistory;
            functionName = "functionName";
            args = "{""arg1"": 1, ""arg2"": 2, ""arg3"": ""3""}";
            funCall = struct("name", functionName, "arguments", args);
            toolCall = struct("type", "function", "function", funCall);
            toolCallPrompt = struct("role", "assistant", "content", "", "tool_calls", []);
            % tool_calls is an array of struct in API response
            toolCallPrompt.tool_calls = toolCall;

            testCase.verifyError(@()addResponseMessage(msgs, toolCallPrompt), "llms:mustBeAssistantWithIdAndFunction");
        end

        function errorsAssistantWithToolCallsWithoutNameOrArgs(testCase, InvalidFuncCallsCases)
            msgs = messageHistory;
            funCall = InvalidFuncCallsCases.FunCallStruct;
            toolCall = struct("id", "123", "type", "function", "function", funCall);
            toolCallPrompt = struct("role", "assistant", "content", "", "tool_calls", []);
            % tool_calls is an array of struct in API response
            toolCallPrompt.tool_calls = toolCall;

            testCase.verifyError(@()addResponseMessage(msgs, toolCallPrompt), InvalidFuncCallsCases.Error);
        end

        function errorsAssistantWithWithNonTextNameAndArguments(testCase)
            msgs = messageHistory;
            funCall = struct("name", 1, "arguments", 2);
            toolCall = struct("id", "123", "type", "function", "function", funCall);
            toolCallPrompt = struct("role", "assistant", "content", "", "tool_calls", []);
            % tool_calls is an array of struct in API response
            toolCallPrompt.tool_calls = toolCall;

            testCase.verifyError(@()addResponseMessage(msgs, toolCallPrompt), "llms:assistantMustHaveTextNameAndArguments");
        end

        function assistantToolCallMessageWithoutArgsIsAdded(testCase)
            msgs = messageHistory;
            functionName = "functionName";
            funCall = struct("name", functionName, "arguments", "{}");
            toolCall = struct("id", "123", "type", "function", "function", funCall);
            % tool_calls is an array of struct in API response
            toolCallPrompt = struct("role", "assistant", "content", "","tool_calls", toolCall);
            msgs = addResponseMessage(msgs, toolCallPrompt);
            % to include in msgs, tool_calls must be a cell
            testCase.verifyEqual(fieldnames(msgs.Messages{1}), fieldnames(toolCallPrompt));
            testCase.verifyEqual(msgs.Messages{1}.tool_calls{1}, toolCallPrompt.tool_calls);
        end

        function assistantParallelToolCallMessageIsAdded(testCase)
            msgs = messageHistory;
            functionName = "functionName";
            args = "{""arg1"": 1, ""arg2"": 2, ""arg3"": ""3""}";
            funCall = struct("name", functionName, "arguments", args);
            toolCall = struct("id", "123", "type", "function", "function", funCall);
            % tool_calls is an array of struct in API response
            toolCallPrompt = struct("role", "assistant", "content", "", "tool_calls", toolCall);
            toolCallPrompt.tool_calls = [toolCall,toolCall,toolCall];
            msgs = addResponseMessage(msgs, toolCallPrompt);
            testCase.verifyEqual(msgs.Messages{1}, toolCallPrompt);
        end

        function messageGetsRemoved(testCase)
            msgs = messageHistory;
            idx = 2;

            msgs = addSystemMessage(msgs, "name", "content");
            msgs = addUserMessage(msgs, "content");
            msgs = addToolMessage(msgs, "123", "name", "content");
            sizeMsgs = length(msgs.Messages);
            % Message exists before removal
            msgToBeRemoved = msgs.Messages{idx};
            testCase.verifyTrue(any(cellfun(@(c) isequal(c,  msgToBeRemoved), msgs.Messages)));

            msgs = removeMessage(msgs, idx);
            testCase.verifyFalse(any(cellfun(@(c) isequal(c,  msgToBeRemoved), msgs.Messages)));
            testCase.verifyEqual(length(msgs.Messages), sizeMsgs-1);
        end

        function removalIdxCantBeLargerThanNumElements(testCase)
            msgs = messageHistory;

            msgs = addSystemMessage(msgs, "name", "content");
            msgs = addUserMessage(msgs, "content");
            msgs = addToolMessage(msgs, "123", "name", "content");
            sizeMsgs = length(msgs.Messages);

            testCase.verifyError(@()removeMessage(msgs, sizeMsgs+1), "llms:mustBeValidIndex");
        end

        function invalidInputsSystemPrompt(testCase, InvalidInputsSystemPrompt)
            msgs = messageHistory;
            testCase.verifyError(@()addSystemMessage(msgs,InvalidInputsSystemPrompt.Input{:}), InvalidInputsSystemPrompt.Error);
        end

        function invalidInputsUserPrompt(testCase, InvalidInputsUserPrompt)
            msgs = messageHistory;
            testCase.verifyError(@()addUserMessage(msgs,InvalidInputsUserPrompt.Input{:}), InvalidInputsUserPrompt.Error);
        end

        function invalidInputsUserImagesPrompt(testCase, InvalidInputsUserImagesPrompt)
            msgs = messageHistory;
            testCase.verifyError(@()addUserMessageWithImages(msgs,InvalidInputsUserImagesPrompt.Input{:}), InvalidInputsUserImagesPrompt.Error);
        end

        function invalidInputsFunctionPrompt(testCase, InvalidInputsFunctionPrompt)
            msgs = messageHistory;
            testCase.verifyError(@()addToolMessage(msgs,InvalidInputsFunctionPrompt.Input{:}), InvalidInputsFunctionPrompt.Error);
        end

        function invalidInputsRemove(testCase, InvalidRemoveMessage)
            msgs = messageHistory;
            testCase.verifyError(@()removeMessage(msgs,InvalidRemoveMessage.Input{:}), InvalidRemoveMessage.Error);
        end

        function invalidInputsResponsePrompt(testCase, InvalidInputsResponseMessage)
            msgs = messageHistory;
            testCase.verifyError(@()addResponseMessage(msgs,InvalidInputsResponseMessage.Input{:}), InvalidInputsResponseMessage.Error);
        end
    end
end

function invalidInputsSystemPrompt = iGetInvalidInputsSystemPrompt()
invalidInputsSystemPrompt = struct( ...
    "NonStringInputName", ...
    struct("Input", {{123, "content"}}, ...
    "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
    ...
    "NonStringInputContent", ...
    struct("Input", {{"name", 123}}, ...
    "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
    ...
    "EmptytName", ...
    struct("Input", {{"", "content"}}, ...
    "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
    ...
    "EmptytContent", ...
    struct("Input", {{"name", ""}}, ...
    "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
    ...
    "NonScalarInputName", ...
    struct("Input", {{["name1" "name2"], "content"}}, ...
    "Error", "MATLAB:validators:mustBeTextScalar"),...
    ...
    "NonScalarInputContent", ...
    struct("Input", {{"name", ["content1", "content2"]}}, ...
    "Error", "MATLAB:validators:mustBeTextScalar"));
end

function invalidInputsUserPrompt = iGetInvalidInputsUserPrompt()
invalidInputsUserPrompt = struct( ...
    "NonStringInput", ...
    struct("Input", {{123}}, ...
    "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
    ...
    "NonScalarInput", ...
    struct("Input", {{["prompt1" "prompt2"]}}, ...
    "Error", "MATLAB:validators:mustBeTextScalar"), ...
    ...
    "EmptyInput", ...
    struct("Input", {{""}}, ...
    "Error", "MATLAB:validators:mustBeNonzeroLengthText"));
end

function invalidInputsUserImagesPrompt = iGetInvalidInputsUserImagesPrompt()
invalidInputsUserImagesPrompt = struct( ...
    "NonStringInput", ...
    struct("Input", {{123, "peppers.png"}}, ...
    "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
    ...
    "NonScalarInput", ...
    struct("Input", {{["prompt1" "prompt2"], "peppers.png"}}, ...
    "Error", "MATLAB:validators:mustBeTextScalar"), ...
    ...
    "EmptyInput", ...
    struct("Input", {{"", "peppers.png"}}, ...
    "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
    ...
    "NonTextImage", ...
    struct("Input", {{"prompt", 123}}, ...
    "Error", "MATLAB:validators:mustBeNonzeroLengthText"),...
    ...
    "EmptyImageName", ...
    struct("Input", {{"prompt", 123}}, ...
    "Error", "MATLAB:validators:mustBeNonzeroLengthText"),...
    ...
    "InvalidDetail", ...
    struct("Input", {{"prompt", "peppers.png", "Detail", "invalid"}}, ...
    "Error", "MATLAB:validators:mustBeMember"));
end

function invalidFunctionPrompt = iGetInvalidFunctionPrompt()
invalidFunctionPrompt = struct( ...
    "NonStringInputName", ...
    struct("Input", {{"123", 123, "content"}}, ...
    "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
    ...
    "NonStringInputContent", ...
    struct("Input", {{"123", "name", 123}}, ...
    "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
    ...
    "EmptytName", ...
    struct("Input", {{"123", "", "content"}}, ...
    "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
    ...
    "EmptytContent", ...
    struct("Input", {{"123", "name", ""}}, ...
    "Error", "MATLAB:validators:mustBeNonzeroLengthText"), ...
    ...
    "NonScalarInputName", ...
    struct("Input", {{"123", ["name1" "name2"], "content"}}, ...
    "Error", "MATLAB:validators:mustBeTextScalar"),...
    ...
    "NonScalarInputContent", ...
    struct("Input", {{"123","name", ["content1", "content2"]}}, ...
    "Error", "MATLAB:validators:mustBeTextScalar"));
end

function invalidRemoveMessage = iGetInvalidRemoveMessage()
invalidRemoveMessage = struct( ...
    "NonInteger", ...
    struct("Input", {{0.5}}, ...
    "Error", "MATLAB:validators:mustBeInteger"), ...
    ...
    "NonPositive", ...
    struct("Input", {{0}}, ...
    "Error", "MATLAB:validators:mustBePositive"), ...
    ...
    "FromEmpty", ...
    struct("Input", {{1}}, ...
    "Error", "llms:removeFromEmptyHistory"), ...
    ...
    "NonScalarInput", ...
    struct("Input", {{[1 2]}}, ...
    "Error", "MATLAB:validation:IncompatibleSize"));
end

function invalidInputsResponseMessage = iGetInvalidInputsResponseMessage()
invalidInputsResponseMessage = struct( ...
    "NonStructInput", ...
    struct("Input", {{123}},...
    "Error", "MATLAB:validation:UnableToConvert"),...
    ...
    "NonExistentRole", ...
    struct("Input", {{struct("role", "123", "content", "123")}},...
    "Error", "llms:mustBeAssistantCall"),...
    ...
    "NonExistentContent", ...
    struct("Input", {{struct("role", "assistant")}},...
    "Error", "llms:mustBeAssistantCall"),...
    ...
    "EmptyContent", ...
    struct("Input", {{struct("role", "assistant", "content", "")}},...
    "Error", "llms:mustBeAssistantWithContent"),...
    ...
    "NonScalarContent", ...
    struct("Input", {{struct("role", "assistant", "content", ["a", "b"])}},...
    "Error", "llms:mustBeAssistantWithContent"));
end

function invalidFuncCallsCases = iGetInvalidFuncCallsCases()
invalidFuncCallsCases = struct( ...
    "NoArguments", ...
    struct("FunCallStruct", struct("name", "functionName"),...
    "Error", "llms:mustBeAssistantWithNameAndArguments"),...
    ...
    "NoName", ...
    struct("FunCallStruct", struct("arguments", "{""arg1"": 1, ""arg2"": 2, ""arg3"": ""3""}"), ...
    "Error", "llms:mustBeAssistantWithNameAndArguments"));
end